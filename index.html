<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Custom Base64 Hangul — 실행 페이지</title>
  <style>
    /* Pretendard 로드 (CDN) */
    @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

    /* 치지직 브랜드 가이드라인: 포인트 컬러 핑크, 배경 블랙, 넉넉한 패딩과 라운딩 */
    :root{
      --bg: #000000;
      --surface: #0b0b0b;
      --muted-surface: #111111;
      --text: #eaeaea;
      --muted-text: #bdbdbd;
      --accent: #ff4da6; /* 포인트 분홍 */
      --radius: 12px;
      --gap: 18px;
    }

    /* 모든 텍스트를 2pt(포인트) 증가시키기: 루트 폰트 크기를 2pt만큼 늘립니다. */
    /* 루트 폰트 크기를 추가로 올렸습니다 (기본보다 +4pt) */
    html { font-size: calc(100% + 4pt); }

    /* Pretendard를 기본 폰트로 설정하고, 모든 폰트는 body에서 상속되도록 합니다. */
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      padding: 40px;
      /* Pretendard를 우선 사용하고, 폴백으로 시스템 폰트를 둡니다. */
      font-family: 'Pretendard', Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      /* 기본 폰트 사이즈는 루트(html)에서 정의되므로 여기서는 1rem을 기준으로 상속됩니다 */
      font-size: 1rem;
    }

    /* 중앙에 컨테이너 (적당한 너비와 내부 패딩) */
    .container{ width:100%; max-width:980px; }

    h1{ color:var(--accent); margin:0 0 12px 0; font-size:1.6rem; text-align:center; }
    p{ color:var(--muted-text); margin:0 0 20px 0; text-align:center }

    /* 모든 텍스트 요소가 body의 폰트를 상속하도록 보장 */
    label, input, textarea, select, button, pre, summary, h1, p { font-family: inherit; }

    .row{ display:flex; flex-direction:column; gap:8px; margin-bottom:var(--gap); align-items:stretch; }
    label{ color:var(--muted-text); font-size:0.95rem; }

    textarea, select, input[type=text], pre#output{
      width:100%;
      max-width:100%;
      background: var(--muted-surface);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.06);
      padding: 14px 16px;
      border-radius: var(--radius);
      box-sizing: border-box;
      outline: none;
      resize: vertical;
    }
    textarea{ min-height:160px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace; }

    select{ padding:10px 12px; border-radius:10px; background:var(--surface); }

    .controls{ display:flex; gap:12px; flex-wrap:wrap; align-items:center }
    button{
      background: linear-gradient(180deg,var(--accent), #ff2d8c);
      color: white;
      border: none;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      font-weight:600;
      box-shadow: 0 8px 24px rgba(255,77,166,0.12);
    }
    button:active{ transform: translateY(1px); }

    pre#output{ min-height:140px; background:var(--surface); padding:18px; border-radius:var(--radius); white-space:pre-wrap; }

    details summary{ color:var(--muted-text); cursor:pointer; }
    details pre{ background:transparent; border:none; padding:0; color:var(--muted-text) }

    @media (max-width:640px){ body{ padding:18px } .container{ max-width:100% } }
  </style>
</head>
<body>
  <div class="container">
    <h1>낑깡어 — 실행 페이지</h1>

    <div class="row">
      <label for="mode">동작:</label>
      <select id="mode"><option value="encode">인코드(텍스트 → 토큰)</option><option value="decode">디코드(토큰 → 출력)</option></select>
    </div>

    <div class="row">
      <label for="input">입력(인코드일 때는 원문, 디코드일 때는 토큰):</label>
      <textarea id="input">hello world</textarea>
    </div>

    <div class="row controls">
      <button id="run">실행</button>
      <button id="run-test">내장 테스트 실행</button>
      <button id="copy-output">출력 복사</button>
    </div>

    <div class="row">
      <label for="output">출력:</label>
      <pre id="output">(대기중)</pre>
    </div>

    <details>
      <summary>사용된 JS 코드(참고)</summary>
      <pre id="pycode" style="white-space:pre-wrap"></pre>
    </details>
  </div>

  <script>
    // 순수 JS 구현: HANGUL_BITS 순서(낑,깡,삐,앙,버,거) -> MSB..LSB
    const HANGUL_BITS = ['낑', '깡', '삐', '앙', '버', '거']; // MSB -> LSB (bit5..bit0)
    const BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const START_DELIM = '뿡';
    const END_DELIM = '뽕';
    const PADDING_MARKER = '=';

    function utf8ToBytes(str) { return new TextEncoder().encode(str); }
    function bytesToUtf8(bytes) { try { return new TextDecoder().decode(bytes); } catch(e) { return null; } }

    function bytesToBase64(bytes){
      let binary = '';
      for(let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }
    function base64ToBytes(b64){
      const binary = atob(b64);
      const arr = new Uint8Array(binary.length);
      for(let i=0;i<binary.length;i++) arr[i] = binary.charCodeAt(i);
      return arr;
    }

    function bytes_to_custom_tokens(dataBytes){
      const b64 = bytesToBase64(dataBytes);
      let out = '';
      for(const ch of b64){
        if(ch === '='){ out += START_DELIM + PADDING_MARKER + END_DELIM; continue; }
        const idx = BASE64_ALPHABET.indexOf(ch);
        if(idx === -1) { console.error('Unknown base64 char:', ch); return ''; }
        let present = '';
        for(let i=0;i<HANGUL_BITS.length;i++){
          const bit = (idx >> (5 - i)) & 1;
          if(bit) present += HANGUL_BITS[i];
        }
        out += START_DELIM + present + END_DELIM;
      }
      return out;
    }

    function custom_tokens_to_bytes(tokenStr){
      let i = 0, n = tokenStr.length;
      let b64_chars = [];
      while(i < n){
        if(tokenStr[i] !== START_DELIM) { console.error(`Invalid format at pos ${i}: expected '${START_DELIM}'`); return null; }
        i++;
        const j = tokenStr.indexOf(END_DELIM, i);
        if(j === -1) { console.error(`Missing end delimiter '${END_DELIM}' after pos ${i}`); return null; }
        const content = tokenStr.slice(i, j);
        i = j + 1;
        if(content === PADDING_MARKER){ b64_chars.push('='); continue; }
        for(const ch of content){ if(!HANGUL_BITS.includes(ch)) { console.error(`Unknown token character '${ch}' inside token`); return null; } }
        let idx = 0;
        for(const hangul of HANGUL_BITS){ idx = (idx << 1) | (content.includes(hangul) ? 1 : 0); }
        b64_chars.push(BASE64_ALPHABET[idx]);
      }
      const b64str = b64_chars.join('');
      return base64ToBytes(b64str);
    }

    document.getElementById('pycode').textContent = `// JavaScript implementation\n// HANGUL_BITS = ${JSON.stringify(HANGUL_BITS)}`;

    document.getElementById('run').addEventListener('click', ()=>{
      const mode = document.getElementById('mode').value;
      const input = document.getElementById('input').value;
      const outEl = document.getElementById('output');
      outEl.textContent = '실행 중...';
      try{
        if(mode === 'encode'){
          const bytes = utf8ToBytes(input);
          outEl.textContent = bytes_to_custom_tokens(bytes);
        } else {
          const bytes = custom_tokens_to_bytes(input);
          if(bytes === null){ outEl.textContent = '오류: 잘못된 토큰 형식입니다.'; return; }
          const hex = Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');
          const text = bytesToUtf8(bytes);
          outEl.textContent = `hex: ${hex}\ntext: ${text === null ? '<binary>' : text}`;
        }
      }catch(e){ outEl.textContent = '오류: ' + e.toString(); }
    });

    document.getElementById('run-test').addEventListener('click', ()=>{
      const outEl = document.getElementById('output');
      outEl.textContent = '테스트 실행 중...';
      try{
        const samples = [new Uint8Array([]), new TextEncoder().encode('f'), new TextEncoder().encode('fo'), new TextEncoder().encode('foo'), new TextEncoder().encode('hello world'), new Uint8Array([0x00,0xff,0x10,0x20])];
        let lines = [];
        let ok = true;
        for(const s of samples){
          const tok = bytes_to_custom_tokens(s);
          const back = custom_tokens_to_bytes(tok);
          const origHex = Array.from(s).map(b=>b.toString(16).padStart(2,'0')).join('');
          if(back === null){
            lines.push(`orig(hex): ${origHex} \n token: ${tok} \n error: token parse failed`);
            ok = false;
            break;
          }
          const backHex = Array.from(back).map(b=>b.toString(16).padStart(2,'0')).join('');
          const origText = bytesToUtf8(s) === null ? '<binary>' : bytesToUtf8(s);
          lines.push(`orig: ${origText}\n token: ${tok}\n back(hex): ${backHex}\n`);
          if(backHex !== origHex){
            lines.push(`roundtrip mismatch: expected ${origHex} but got ${backHex}`);
            ok = false;
            break;
          }
        }
        if(ok) lines.push('All tests passed.');
        outEl.textContent = lines.join('\n');
      }catch(e){ outEl.textContent = '테스트 실패: ' + e.toString(); }
    });

    document.getElementById('copy-output').addEventListener('click', async ()=>{
      const out = document.getElementById('output').textContent;
      try{ await navigator.clipboard.writeText(out); alert('출력이 클립보드에 복사되었습니다.'); }
      catch(e){ alert('복사 실패: ' + e); }
    });
  </script>
</body>
</html>
